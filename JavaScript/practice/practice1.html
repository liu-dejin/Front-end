<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    document.write('jsnb')
    // alert('null')
    /*     alert('111')
        alert('111')
        alert('111')
        alert('111') */
    console.log('111')
    /* let uname = prompt('请输入你的年龄')
    document.write(uname) */

    // 交换变量
    let num1 = 'pink'
    let num2 = '刘德华'
    let temp
    temp = num1
    num1 = num2
    num2 = temp
    console.log(num1, num2)

    let arr = ['ldj', 'njj', 'lmm']
    console.log(arr.length)

    const PI = 3.14
    console.log(PI)

    //NaN表示计算错误
    console.log('老师' - 2) //NaN
    // NaN具有粘性,任何对NaN的操作都会返回NaN

    //字符串拼接
    /*     let uname = prompt('请输入你的姓名')
        let age = prompt('请输入你的年龄')
        document.write(`大家好,我是${uname},今年${age}`) */


    // undefined
    let nu
    console.log(nu) //undefined
    //在开发中我们不知道是不是有一个值传过来,此时我们就可以检测这个变量是不是undefined

    //null  空的 作为尚未创建的对象 将来有个变量里面存放的是一个对象，但是对象还没创建好，可以先给个null
    let obj = null
    console.log(obj) //null

    // 区别
    // undefined表示没有赋值,null表示赋值了但为空
    console.log(undefined + 1) //NaN
    console.log(null + 1) //1

    let type1 = 10
    console.log(typeof type1) //num
    let type2 = '10'
    console.log(typeof type2) //str
    let type3 = 'ldj'
    console.log(typeof type3) //str
    let type4 = false
    console.log(typeof type4) //Boolean
    let type5
    console.log(typeof type5) //unfefined
    let type6 = null
    console.log(typeof type6) //obj

    //类型转换
    //使用表单、prompt 获取过来的数据默认是字符串类型的
    // 1.隐式转换 
    //+两边只要有字符串否会另一个转换为字符串
    console.log('pink' + 1) // pink1
    console.log(2 + 2)   // 4
    console.log(2 + '2') // 22
    //除了+以外的算术运算符都会把数据转换为数字类型
    console.log(2 - 2)    // 0
    console.log(2 - '2')  // 0
    //小技巧
    // +号作为正号解析可以转换成数字型
    console.log(+'123')  // 转换为数字型 123
    // 任何数据和字符串想加都是字符串

    // 2.显式转换
    /*     Number(数据) //转成数字类型,如果字符串内容里面有非数字.转换失败时结果为NaN,即不是一个数字    NaN也是number类型的数据,表示非数字
        parseInt(数据) //只保留整数
        parseFloa(数据) //可以保留小数
    
        转换为字符型:
        String(数据)
        变量.toString(进制) */

    //赋值运算符 =
    // 一元运算符 自增 自减
    let i = 1
    console.log(++i + 2) //4  ++在前 先加
    let i1 = 1
    console.log(i1++ + 2) //3 ++在后 后加
    //独立使用无差别,一般后置自增使用较多

    //比较运算符 < > <= >= == === !== 比较运算符有隐式转换。比较结果为boolean类型，即只会得到true或false
    /*     = 和 == 和 === 对比：
    
        = 单等是赋值
    
        == 是判断
    
        === 是全等  强烈推荐使用 */
    /*     字符串比较是比较ASCII码,从左往右一次比较,如果第一位一样在比较第二位
        NaN不等于任何值,包括他自身,涉及到NaN都是False
        劲量不要比较小数,小数涉及精度问题
        不同类型之间比较会发生隐式转换,最终转成number类型再比较,所以开发中,更腿甲===或者!== */

    //逻辑运算符
    /*     && 一假则假 表达式1 && 表达式2：表达式1为真，返回表达式2；表达式1为假，返回表达式1
        ||一真则真 表达式1  ||  表达式2：表达式1为真，返回表达式1；表达式1为假，返回表达式2 
        !取反
        逻辑非优先级很高,逻辑与必逻辑或高先&&再||
        */

    // if语句
    /*     if (条件1) {
          代码1
        } else if (条件2) {
          条件2
        } else if (条件3) {
          条件3
        } else {
    
        } */
    //三元运算符
    // 条件 ? 满足条件执行的代码 : 不满足条件执行代码


    //数组 
    /*     arr.push
        arr.unshift
    
        arr.pop
        arr.shift
    
        arr.splice(start, deleteCount)
     */
    //数组排序

    let arr1 = [4, 2, 5, 1, 3]
    // 1.升序排列写法
    arr1.sort((a, b) => a - b)
    console.log(arr1) //[1, 2, 3, 4, 5]
    // 降序排列写法
    arr1.sort((a, b) => b - a)
    console.log(arr1) // [5, 4, 3, 2, 1]


    //函数
    /*     function 函数名(形参...) {
          函数体
          return
        }
        函数名(实参) */
    /*     如果形参过多 会自动填上undefined(了解即可)
        如果实参过多 那么多余的实参会被忽略(函数内部有一个arguments，里面装着所有的实参) */



    /*     let a = 1
        function fn1() {
          let a = 2
          let b = '22'
          fn2()
          function fn2() {
            let a = 3
            fn3()
            function fn3() {
              let a = 4
              console.log(a) //a的值 ?
              console.log(b) //b的值 ?
            }
          }
        }
        fn1()  */

    //匿名函数  函数表达式和立即执行函数
    // let fn1 = function () { 函数体 }
    // fn1() //必须先声明再调用

    //   (function () { console.log(12) })();
    // (function () { console.log(11) }());

    // 注意： 多个立即执行函数要用 ; 隔开，要不然会报错 

    //逻辑中断
    // 注意： 多个立即执行函数要用 ; 隔开，要不然会报错 
    // 表达式1 && 表达式2：表达式1为真，返回表达式2；表达式1为假，返回表达式1

    // 表达式1  ||  表达式2：表达式1为真，返回表达式1；表达式1为假，返回表达式2

    // 转换为boolean
    // 显式转换:
    // 记忆 ： ‘’ 、0、undefined、null、false、NaN 转换为布尔值后都是false, 其余则为 true
    //隐式转换:
    /*  1. 有字符串的加法 “” + 1 ，结果是 “1”
        2. 减法 - （像大多数数学运算一样）只能用于数字，它会使空字符串 "" 转换为 0
        3. null 经过数字转换之后会变为 0
        4. undefined 经过数字转换之后会变为 NaN */

    //对象 无序数据集合
    // let 对象名 = {}   let 对象名 = new Object()

    /*     let 对象名 = {
          // 多个属性之间使用英文 , 分隔
          属性名: 属性值, //属性/方法名可以使用 "" 或 ''
          方法名: 函数
        } */
    //对象的增删改查
    let person = {
      'user-name': 'pink老师',
      age: 19,
      gender: '女'
    }
    console.log(person.age)
    console.log(person.gender)
    console.log(person['user-name']) //对于多词属性或则 - 等属性，点操作就不能用了
    /*     修改属性： 对象名.属性 = 新值
        增加属性： 对象名.新属性 = 新值
        删除属性： delete 对象名.属性 */

    let obj1 = {
      uname: "anby",
      age: 19,
      sex: '男'
    }
    for (const key in obj) {
      console.log(key) //打印属性名
      console.log(obj[key]) //打印属性值
    }

  </script>
</body>

</html>